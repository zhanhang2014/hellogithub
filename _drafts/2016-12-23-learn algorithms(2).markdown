---
layout:     post
title:      "算法学习笔记(2) 指针操作"
subtitle:   "Start pointer of Hello World"
date:       2016-12-23 03:40:00
author:     "Hang"
header-img: "img//2016-06-03/head-bg.jpg"
catalog: true
tags:
    - 技术
---

## 指针基础

一个指针是一个变量，它存储数据在内存中的地址而不是存储数据本身。指向无效地址的指针被称为悬空指针。可能产生悬空指针的编程错误包括：将任意的整型变量强制转换为指针变量；操作超出数组边界的指针；释放一个或多个仍被引用的指针。

## 存储空间分配

与声明其他类型的变量类似，声明一个指针时，一定量的存储空间会分配给这个指针。当声明一个指针时，仅仅是为指针本身分配了空间，并没有为指针所引用的数据分配空间。为数据分配存储空间的方法有两种：直接声明一个变量或在运行时动态分配存储空间（例如malloc或realloc）。

当声明一个变量时，编译器会根据变量的类型预留足够的内存空间。变量的存储空间是系统自动分配的，此存储空间不会在程序的整个生命周期中永久存在。自动变量是一种在进入或离开一个模块或函数时其存储空间能够自动分配和释放的变量。

```
int f(int **iptr){
	int a = 10;
	*iptr = &a;
	return 0;
}
```
以上函数f中，iptr的赋值为变量a的地址，当函数f返回时，iptr变成了一个悬空指针。因为此时变量a已经从函数栈中弹出。

在C语言中，想要动态分配存储空间时，我们会得到一个指向一个堆存储空间的指针。此存储空间由我们自行管理，并且会一直存在，直到我们显式的将它释放。

```
#include <stdlib.h>

int g(int **iptr){
	if((*iptr=(int *)malloc(sizeof(int)))==NULL){
		return -1;
	}
	return 0;
}
```

以上代码中用malloc分配的存储空间会一直有效直到调用函数free来释放它。当函数g返回时此存储空间仍然有效。

如果动态分配了内存空间但从未释放它就会造成内存泄漏。可以采用统一的内存管理方法来减少此类问题。

## 数据集合与指针的算术运算

指针在C语言中最常见的用途就是用来引用数据集合。数据集合是由多个相关联的元素构成的数据。C语言支持两种数据集合：结构和数组。

#### 结构

结构通常是由各种有序的元素组成的，从而它可以被看做单个连续的数据类型。结构指针是构建一个数据结构的重要组成部分。结构使我们能够把数据捆绑在一起，指针使我们能够让这些捆绑包在内存中一个个连接起来。例如把内存中一些元素组合起来形成一个链表：

```
typedef struct ListElmt_ {
	void *data;
	struct ListElmt_ *next;
} ListElmt;
```

结构ListElmt也指出了关于结构指针的另一个重要方面：结构不允许包括自身的实例，但是可以包含指向自身实例的指针。

#### 数组

数组是在内存中连续排列的同类元素的序列。当一个数组标识符在表达式中出现时，C语言会把数组转换为一个指向数组第一个元素的固定指针。以下两个函数是等价的：

```
int f(){
	int a[10],*iptr;
	iptr=a;
	iptr[0]=5;
	return 0;
}

int g(){
	int a[10],*iptr;
	iptr=a;
	*iptr=5;
	return 0;
}
```
访问一个数组的第i个元素用表达式：

```
a[i]
```
这也等同于：

```
*(a+i)
```

这实际上是使用指针的规则来访问数组元素。对于多维数组：

```
a[i][j]
```

也类似：

```
*(*(a+i)+j)
```

## 作为函数参数的指针

使用指针传递大容量复杂的函数参数是十分高效的手段，因为我们只需要传递一个指针而不是一个数据的完整副本到函数中，大大节省了内存空间。

#### 按引用调用传递参数

我们使用swap的例子来说明按引用调用传递参数。

错误的交换：

```
void swap1(int x,int y){
	int tmp;
	tmp=x; x=y;y=tmp;
	return;
}
```

正确的交换：

```
void swap2(int *x,int *y){
	int tmp;
	tmp=*x;*x=*y;*y=tmp;
	return;
}
```

当把一个多维数组传递给函数时，除了第一维以外，其他维度的长度必需指定，这样才能通过指针算术运算访问具体元素。因为想要访问任意一行的元素，我们首先必需确切知道到达这一行我们需要跳过多少元素。

#### 作为参数指向指针的指针

向函数传递一个待改变的指向指针的指针，可以通过函数改变传递给它的指针。

## 泛型指针与类型转换

在不关心指针所指向的变量的类型时，可以使用泛型指针，泛型指针并不指定具体的数据类型。

#### 泛型指针

通常情况下，C语言之允许相同类型的指针之间进行转换。但是，泛型指针能够转换为任何类型的指针，反之亦然。在C语言中，通常声明一个void指针来表示泛型指针。例如，将之前的swap2函数的参数改为void指针，这样swap2就变成可以交换任意数据类型的通用交换函数了：

```
#include <stdlib.h>
#include <string.h>

int swap2(void *x,void *y,int size){
	viod *tmp;

	if((tmp=malloc(size))==NULL)
		return -1;
	memcpy(tmp,x,size);memcpy(x,y,size);memcpy(y,tmp,size);
	free(tmp);
	return 0;
}
```

#### 类型转换

要将类型为T的变量t转换成S类型，只需要在t前面加上用圆括号括上的S。对于泛型指针来说类型转换非常重要，因为只有告诉泛型指针是通过何种类型来访问地址时，泛型指针才能正确取值。使用类型转换也是一种很好的代码自注释方法，可以提高程序的可读性。

当转换指针时，我们要特别注意内存中的数据对齐方式。指针的类型转换会破坏计算机本身的对齐方式。很多计算机对对齐的方式有要求，以便某些硬件优化可以使访问内存更有效率。所以，如果有一个非按字对齐的void指针，当它转换为一个整型指针并试图获取它的值时，程序可能在运行时出现异常。

## 函数指针

函数指针是指向可执行代码段或调用可执行代码段的信息块的指针，而不是指向某种数据的指针。函数指针的一个重要用途是将函数封装到数据结构中。