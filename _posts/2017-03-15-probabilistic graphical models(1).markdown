---
layout:     post
title:      "图形概率模型(1) 基本介绍和朴素贝叶斯分类器"
subtitle:   "今天日记空白没有关系，不必每件事情都在意"
date:       2017-03-15 02:56:00
author:     "Hang"
header-img: "img//2016-06-03/head-bg.jpg"
catalog: true
tags:
    - 技术
---

陆陆续续开了一些博客系列，不过进度都好慢呀。17年原本满满打算多写一些文字的，还有那些关于文学音乐和电视剧的内容想写。转眼都是三月半了，还要多加油呀。

这个图形概率模型(Probbilistic Graphical Models)是Coursera上的一个系列课程。从多方面来说我都觉得很有用，今年第一要学好的课程(此外还有Python数据处理、人群与网络、数字信号处理、乐理基础)。希望在博客里做个复习总结和进度督促吧，学习的其他课也陆续放上！

## 因素(Factors)

因素是这门课基础中的基础，是描述这一整个知识体系的语言。因素表看起来比较像一个状态描述表+可能取值的罗列。围绕因素的一些基本操作则可以刻画图形概率模型的状态和属性。

## 概率流

概率网络中的不同节点是可以相互关联和作用的。

## 条件独立

## 朴素贝叶斯

## 实践：简单贝叶斯知识引擎

写这篇博客的时候第一周的内容我已经学习完了，所以博客的正文其实是从这里开始写起的。

#### 综述

这次的实践主要是熟悉贝叶斯网络。首先我们会使用SAMIAM软件设计一个简单的贝叶斯网络来计算信誉。然后我们自己用因素操作实现SAMIAM中的一些功能。

#### 使用SAMIAM

使用SAMIAM的编辑模式可以修改贝叶斯模型的边和节点的条件概率(注意保持其他属性不变)。在完成的贝叶斯网率中可以使用查询模式来观测节点状态。在菜单中可以选择查看所有的状态。

我们使用的网络中有用户income、assets、ratio of debts to income、payment histor、age、credit-worthiness和future income。

![](/img/2017-03-15/credit.jpg)

各属性需要满足以下条件：

1. 一个人的支付记录越好，这个人就越可靠；
2. 一个人的年龄越大，这个人越可靠；
3. 一个人的年龄越大，他的支付记录可能越好；
4. 一个人的负债占比越大，他的支付记录可能越差；
5. 一个人的收入越高，其所持有的资产可能越多；
6. 一个人的资产越多，收入越高，那么他未来的收入可能越高；
7. 在其他条件相同的情况下，可靠的人的信誉要高于不可靠的人。同样，未来可能收入高的人或者负债比低的人也有更高的信誉。

根据以上条件我们来构造贝叶斯网络的关系以及各标签条件概率分布CPD(conditional probilistic distribution)，一下是我实现的一个例子。

![](/img/2017-03-15/bn.jpg)

可以在查询模式中修改观测状态来检验概率变动是否和我们当初设计的一致。

#### 计算贝叶斯网络中的概率

##### 基本因素操作

我们使用因素来表示贝叶斯网络中的条件概率分布，因素操作的核心是乘法(product)，边缘化(marginalization)和化简(reduce)。我们使用MATLAB来实现这几个操作。

首先我们要定义MATLAB中用于表示因素的数据结构，这样的数据结构需要包含3个要素：变量数以及其顺序；每个变量的取值范围，变量的具体值。例如，我们用

```
 phi = struct('var', [3 1 2], 'card', [2 2 2], 'val', ones(1, 8));
```

所得到的结果就是一个有三个变量X_3, X_1, X_2,其取值范围都是二元(binary)的因素表，其值都设为1.

```
% -+-----+-----+-----+-------------------+   
%  | X_3 | X_1 | X_2 | phi(X_3, X_1, X_2)|
% -+-----+-----+-----+-------------------+
%  |  1  |  1  |  1  |     phi.val(1)    |
% -+-----+-----+-----+-------------------+
%  |  2  |  1  |  1  |     phi.val(2)    |
% -+-----+-----+-----+-------------------+
%  |  1  |  2  |  1  |     phi.val(3)    |
% -+-----+-----+-----+-------------------+
%  |  2  |  2  |  1  |     phi.val(4)    |
% -+-----+-----+-----+-------------------+
%  |  1  |  1  |  2  |     phi.val(5)    |
% -+-----+-----+-----+-------------------+
%  |  2  |  1  |  2  |     phi.val(6)    |
% -+-----+-----+-----+-------------------+
%  |  1  |  2  |  2  |     phi.val(7)    |
% -+-----+-----+-----+-------------------+
%  |  2  |  2  |  2  |     phi.val(8)    |
% -+-----+-----+-----+-------------------+
```



###### 因素乘法

因素乘法要解决的问题有：

1) 合并变量，我们直接使用MATLAB的union函数；
2) 找到原因素表与结果表之间的指数映射关系，我们利用了提供的IndexToAssignment和AssignmentToIndex两个函数。

解决了这两个问题，乘法本身是trival的不多说了，代码可以在我的github上找到。

###### 边缘化

边缘化需要从原因素表中去掉某几个特征量，即将剩下的变量的相同组合做一个合并。操作方法：

1) 类似于union，使用setdiff找到边缘化后剩下的特征量以及和原因素表的映射关系。
2) 找到映射关系后，可以用循环的方式来合并相同项：
```
for n = 1:length(indxB)
   B.val(indxB(n)) = A.val(n) + B.val(indxB(n));
end
```

###### 化简

因素的化简是将已经观察到的特征变量标记，将该变量不符合标记值的所有组合结果置0。使用嵌套循环来实现这一功能，外层循环找到观测结果的变量和值，内层循环对每张因素表做修改。修改过程注意可以使用矢量化的技巧避免循环嵌套过深。

```
assignments = IndexToAssignment(1:prod(F(j).card), F(j).card);
[mapF,~,~] = find(assignments(:,indx) ~= x);
indxF = AssignmentToIndex(assignments(mapF,:), F(j).card);
F(j).val(indxF) = 0;
```

##### 计算联合概率分布

有了以上的因素基本操作函数，计算联合概率分布就十分方便了。在假设因素都符合条件概率的情况下，应用贝叶斯网络的链式法则我们只需要对因素表做因素乘法即可：

```
for i = 1:length(F)
   Joint = FactorProduct(Joint,F(i)); 
end
```

##### 计算边际

对于一个结构已知的贝叶斯网络，在使用因素表求得联合概率分布之后，若取得某些特征的观测值，则可以再以此计算边缘分布。
计算边缘分布的步骤为：

1) 计算联合概率分布；
2) 将已知观测值化简；
3) 边缘化化简后的因素表；
4) 归一化为概率分布。

值得注意的是在边缘化的时候由于观测值变量集合可能与因素表有不同的部分，需要使用交集setdiff进行处理。四个步骤的MATLAB代码：

```
M = ComputeJointDistribution(F);
M = ObserveEvidence(M, E);
M = FactorMarginalization(M, setdiff(M.var,V));
M.val = M.val./sum(M.val);
```

##### 用自己编写的函数查询信誉网络

为了验证我们编写的函数的正确性，可以用课程提供的转换函数将SAMIAM软件中的贝叶斯网络转换到MATLAB中比较不同边界情况的结果。
转换的方式为：

```
[F, names, valNames] = ConvertNetwork('Credit_net.net');
```

例如这个时候我们希望知道在其他条件相同的情况下，超过65岁的低债务低收入人群的信誉分布，在SAMAIAM软件中可以看到：

![](/img/2017-03-15/example.jpg)

如果我们使用之前编写的MATLAB程序来计算则有：

```
[F, names, valNames] = ConvertNetwork('Credit_net.net');
A = ComputeMarginal([1], F, [4 3;5 3;7 1]);
A
A = 
     var: 1
    card: 2
     val: [0.6571 0.3429]
```

结果与软件所得一致。
